屏幕理解一键代办智能体（Snap2Action）
办公学习
多模态大模型（VLM+LLM）、端侧OCR与版式理解、结构化信息抽取（IE）、工具调用（Function Calling）、RAG（企业知识/个人知识）、端云协同与隐私计算（本地向量索引/脱敏）
Android 手机（悬浮窗/侧边栏/通知栏）

微信/邮件/飞书/浏览器等“看到信息就要执行”的场景
对当前屏幕内容（截图/通知）进行语义理解，自动抽取时间地点人物事项，生成“建日程/加待办/生成回复/路线提醒”等可执行卡片，一滑确认即可落地执行，显著减少复制粘贴与漏办。

相关项目很多，得往端策隐私方向考虑
DEMO——运行逻辑
先实现三个场景（新建日程，一键导航，加待办等）
1. 点击悬浮球->自动截图->从截图中进入
2. 后端分析后自动生成“可执行卡片”（抽取时间/地点/事项/联系人/链接）可以多个可选
3. 用户滑动确认
4. 自动化执行（建日历、导航、生成回复/待办等）
5. app中能看到操作历史（至少能看到“解析依据片段”或“来源文本”）
   时间线及分工
   分工
   A：前端UI，把BC的工作串联起来
- 悬浮球截屏，把图片传到后端
- 后端分析后会有actionplan，做卡片界面：把识别出来的事项、时间、地点展示出来，让用户可以修改（这个可选），然后点一下或者滑一下执行。
- 负责权限申请、失败提示、重试、loading 这些体验细节
  B：负责模型的调用，意图识别
- 图片就先 OCR 成文字
- 再把文字里时间/地点/事项抽出来（规则+大模型）
- 最后输出一个固定格式的 ActionPlan
  C：负责自动话执行
- 负责“创建日程、打开地图导航、加待办”等这些自动化动作的代码。提供相关的接口
- 尽量都走系统 Intent/Provider（安卓专门用来调用的一些组件功能）

---
里程碑DDL
Day 1（上午必须把接口定死，下午各自开干）
三个人一起（上午）
- 把 ActionPlan 的字段定死：有哪些 action、每个 action 要哪些 slots（title/time/location/reply_text 等），JSON 长什么样。
- 在项目里建好 core-model：Kotlin data class + JSON 序列化/反序列化。
  A（下午）
- 把 Android 工程跑起来，做一个最简单的“卡片列表页面 + 详情编辑页面（先空数据也行）”。
- 把 Share Intent 接进来：别的 App 分享文字/图片到你们 App 时能接到。
  B（下午）
- 先不管 OCR/模型，直接写一个“假解析器”：输入一段文本，固定输出一份 ActionPlan（mock 数据），确保 schema 能跑通。
  C（下午）
- 先不管 B 的输出，写 ActionExecutor 的骨架。
- 用写死的数据把“打开系统日历创建页”“打开地图导航”跑通。
  当日验收
- Share 进来一段文字 → A 显示卡片 → 点按钮能弹出系统日历/地图（哪怕数据是写死的）。

---
Day 2（入口先做实，执行先做稳）
A
- 做通知监听（NotificationListenerService）：能拿到通知标题/正文/包名，送进你们的处理流程。
- 卡片编辑页做成可用：title/time/location 能改，点确认能把修改后的数据传给执行器。
  B
- 接 ML Kit OCR：share_image 进来一张图，能 OCR 出文本。
- 做时间解析第一版：能处理“今天/明天/后天/下周X/下午两点”这类，输出成明确日期时间（ISO）。
  C
- 日历动作走两条路：优先用系统插入 Intent，权限不够时也能弹系统创建页，不要直接崩。
- 地图导航用 geo: 或常见地图 Intent，传 location 字符串就能跳。
  当日验收
- 通知文本能进来 → 规则抽出时间/标题 → 出卡片 → 修改后能成功建日程。

---
Day 3（必须跑通“真实入口 + 真实执行”的第一条完整链路）
A
- 把三种来源统一成一个 RawInput（notification / share_text / share_image），处理流程不要分叉写三套。
- 卡片加 loading、失败提示、重试按钮（先粗糙也行）。
  B
- Parser 输出 ActionPlan v1：至少能稳定输出 CREATE_CALENDAR_EVENT 和 NAVIGATE 两种 action。
- 给每个字段加个简单 confidence（规则命中就高，不确定就低）。
  C
- 加两个简单动作：COPY_TEXT（复制到剪贴板）和 DRAFT_REPLY（走分享面板发出去/或者先复制）。
- ActionExecutor 统一返回 ExecResult（成功/失败/原因）。
  当日验收
- 至少 2 个入口（通知 + 分享）+ 至少 2 个动作（日历 + 地图/复制）能端到端跑通。

---
Day 4（开始“像样一点”：覆盖模板、减少误判）
A
- UI 上把低置信度标出来：比如时间不确定就提示“需要你确认”，默认打开编辑。
- 加一个“最近记录”列表（简单存内存/本地都行），方便回看测试。
  B
- 扩充规则模板：会议、上课、作业截止、地址链接、快递、缴费提醒等，至少补到 30 条样例。
- 输出 evidence：把命中的文本片段带上（先不做 bbox，高亮用文本片段就够）。
  C
- 做去重：同一条通知反复触发不要反复建日程（用 title+time+source 做 key）。
- 失败原因要讲人话：比如“时间没解析出来”“没有地图 App”等。
  当日验收
- 拿 10 条真实通知/文本喂进去，至少 7 条能给出合理的主 action，而且不会乱执行。

---
Day 5（上限提升：必要时才用大模型）
A
- 支持“主建议 + 备选建议”最多两条（比如一条建日程，一条复制文本），用户点哪个执行哪个。
- 编辑页体验顺一下：改完立刻刷新卡片内容。
  B
- 加 LLM（如果你们决定用）：只在规则 confidence 低时调用。
- LLM 输出必须是严格 JSON，不合格就丢弃，回退规则结果。
- 做简单脱敏（手机号/身份证/金额等打码）再上云（有就做，没有也不致命，但做了更稳）。
  C
- DRAFT_REPLY 做到“可直接走分享面板发出去”，不要只停留在复制。
- 确保每个 action 都能在没有权限/没有目标 App 的情况下给出兜底提示，而不是崩溃。
  当日验收
- 复杂一句话（包含相对时间+地点+事项）能稳定生成日程卡，且用户改一下也能执行。

---
Day 6（稳定性和性能日，必须把“不会炸”做到位）
A
- 全部流程异步化：不要在主线程跑 OCR/解析。
- 通知入口要节流：连续来很多通知不会卡死，不会刷屏生成几十张卡。
  B
- OCR 图片先压缩再识别，限制输入分辨率，缓存 OCR 结果。
- 解析失败要清晰：返回“解析失败”而不是空 JSON 或崩。
  C
- 执行状态机：执行中/成功/失败，重复点不会重复建日程。
- 多机型权限流程再过一遍，至少保证“没权限也能弹系统创建页”。
  当日验收
- 连续处理 20 次输入不崩；从触发到出卡在可接受范围（几秒级）并且 UI 不卡。

---
Day 7（补边界 + 拉齐体验）
A
- 暗色模式、不同分辨率下 UI 不错位。
- 权限引导写清楚：为什么要这个权限，不给权限会怎样（至少不会让用户死在第一步）。
  B
- 补边界 case：只有地点没有时间、只有时间没有标题、文本被截断、数字格式奇怪等。
- 调整规则优先级，减少明显误判。
  C
- 再加一个“轻量但实用”的动作（别太贪）：比如识别到 URL 就打开，或识别到快递单号就复制并跳查询网页。
- 把错误提示再收敛一下，别一堆技术栈报错。
  当日验收
- 至少 3–4 类场景（会议/课程/地址/提醒）能稳定跑通，且用户体验不别扭。

---
Day 8（只收口，不加新功能）
A
- 修 UI bug、修权限流程、修崩溃点；把 loading/失败/重试再顺一遍。
  B
- 强化 JSON 校验：字段缺失就补默认值/直接回退；确保不会输出半截东西把 A/C 搞崩。
  C
- 最后核对日历字段（时区、开始结束时间、地点），核对地图 intent 参数。
- 补日志开关：现场出问题能快速定位是入口问题、解析问题还是执行问题。
  当日验收
- 你们选定的固定演示流程连续跑 10 次不翻车。

---
如果你们按这个做，A/B/C 的工作基本不会互相等：
- A 可以一直用 mock ActionPlan 做 UI 和流程；
- C 可以一直用 mock slots 做执行器；
- B 自己把 OCR/规则/模型调好，最后把输出对齐 schema 就能接上。